= Encryption Model

Our encryption module contains the following classes:

- CryptUtils
- AESCipher 
- RSACipher

== Requirements
Our Encryption tools must have the following data:

- Encryption key(s)
- Password Salt
- Encrypted ciphertext 

== CryptUtils
CryptUtils defines a set of reusable methods for both AES and RSA ciphers (i.e it is not specific to one encryption standard).

.Methods
CryptUtils can only

- Generate random byte arrays for use in salts, or initialization vectors (IVs).


== AES Cipher
AES Cipher contains helper methods for use in both encryption and decryption of data. 
AES Cipher stores the following member variables

- byte[] iv
- byte[] salt
- Secretkey key

.Methods
AESCipher can 
- Generate AES keys, password hashes/keys 
- Encrypt and Decrypt plaintext and ciphertext in AES-256 GCM with no padding
- Generate prefix headers for attaching iv, salt to ciphertext
- Parse headers for obtaining iv, salt, ciphertext

== RSA Cipher




With our models we must be able to do the following on our client's end:

- Encrypt our data in AES-256 GCM format.
- Decrypt our data
- Encode our data in base64
- Store our keys, salt (In member vars and possibly to keystore). +

- Securely generate random keys
- Securely generate AES keys
- Securely generate RSA keys too maybe, might be useful
- Securely generate random salt
- Securely generate random passwords

*We need to do an awful lot of random stuff here, maybe make a random class?*

- Test for proper padding, and block sizes if that isn't handled by lib. +

- Do a test with a bit of php just to see if it will be properly handled by it +

- Test with mocks and php frontend later -> for server later
- Test with mocks in java application -> for client

*Note* We could possibly define a Data class


- Possibly encrypt files

*To Be Implemented*

*To Be Considered*
- Client side certificate validation 
- Merge CryptUtils with CryptAES? 


=== Encrypt
Encrypt should take a key (AES or RSA), some plaintext (our message), and/or an IV and/or a Salt.

Encrypt should then be able to return back the ciphertext (or maybe it returns a tuple with the ciphertext, key, and/or iv, and/or salt)


== TODO

== Discussion
- Wrap data up in .json format for easy access?
- Send data as base64 file? Most likely as we'll need to temporarily save it, or perhaps just use java listener

== Possible Features
SSL Configuration for key and data transmission.

=== Priority Features
